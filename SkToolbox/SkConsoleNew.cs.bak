using SkToolbox.Utility;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// A console to display Unity's debug logs in-game.
/// Credit: github. com/ mminer/ consolation Thank you for this!!
/// </summary>
namespace SkToolbox
{
    internal class SkConsoleNew : MonoBehaviour
    {
        public static Version SkConsoleVersion = new Version(1, 1, 1);

        #region Inspector Settings

        /// <summary>
        /// The hotkey to show and hide the console window.
        /// </summary>
        public KeyCode toggleKey = KeyCode.BackQuote;

        /// <summary>
        /// Whether to open as soon as the game starts.
        /// </summary>
        public bool openOnStart = false;

        /// <summary>
        /// Whether to open the window by shaking the device (mobile-only).
        /// </summary>
        public bool shakeToOpen = false;

        /// <summary>
        /// Also require touches while shaking to avoid accidental shakes.
        /// </summary>
        public bool shakeRequiresTouch = false;

        /// <summary>
        /// The (squared) acceleration above which the window should open.
        /// </summary>
        public float shakeAcceleration = 3f;

        /// <summary>
        /// The number of seconds that have to pass between visibility toggles.
        /// This threshold prevents closing again while shaking to open.
        /// </summary>
        public float toggleThresholdSeconds = .5f;
        private float lastToggleTime;

        /// <summary>
        /// Whether to only keep a certain number of logs, useful if memory usage is a concern.
        /// </summary>
        public bool restrictLogCount = true;

        /// <summary>
        /// Number of logs to keep before removing old ones.
        /// </summary>
        public int maxLogCount = 1000;

        /// <summary>
        /// Font size to display log entries with.
        /// </summary>
        public int logFontSize = 12;
        private int logLineNumber = 0;
        /// <summary>
        /// Amount to scale UI by.
        /// </summary>
        public float scaleFactor = 1f;

        public static bool writeToFile = false;

        public static bool cursorUnlock = false;

        public static bool enableInput = true;
        #endregion

        private string logSavePath;
        private SkCommandProcessor commandProcessor;
        private History consoleHistory = new History();

        //private const int margin = 150;
        private const string windowTitle = "Console [SkToolbox]";
        private static readonly Dictionary<LogType, Color> logTypeColors = new Dictionary<LogType, Color>
        {
            { LogType.Assert, Color.white },
            { LogType.Error, Color.red },
            { LogType.Exception, Color.red },
            { LogType.Log, Color.white },
            { LogType.Warning, Color.yellow },
        };
        private bool isCollapsed;
        private bool isVisible;
        private bool announcedCmds = false;
        private Font customFont;
        private readonly List<Log> logs = new List<Log>();
        private readonly ConcurrentQueue<Log> queuedLogs = new ConcurrentQueue<Log>();
        private Vector2 scrollPosition;
        private readonly Rect titleBarRect = new Rect(0, 0, 10000, 20);
        //private float windowX = margin;
        //private float windowY = margin;
        //private float width;
        //private float height;

        private InputField inputField;

        private readonly Dictionary<LogType, bool> logTypeFilters = new Dictionary<LogType, bool>
        {
            { LogType.Assert, false },
            { LogType.Error, false },
            { LogType.Exception, false },
            { LogType.Log, true },
            { LogType.Warning, false },
        };

        #region MonoBehaviour Messages

        private void OnDisable()
        {
            Application.logMessageReceivedThreaded -= HandleLogThreaded;
        }

        private void OnEnable()
        {
            Application.logMessageReceivedThreaded += HandleLogThreaded;
        }


        InputField conInput;
        Button buttonSubmit;
        Button buttonClear;
        UnityEngine.UI.Text conOutput;
        GameObject Content;
        GameObject prefabInstance;
        private void Start()
        {
            prefabInstance = Instantiate(Resources.Load("SkConsolePrefab")) as GameObject;
            logSavePath = Application.persistentDataPath + "/!SkToolbox Console Log.txt";

            SkCommandProcessor.Instance.DiscoverCommands();

            customFont = Font.CreateDynamicFontFromOSFont("Consolas.ttf", logFontSize);
            //width = (Screen.width / scaleFactor) - (margin * 2);
            //height = (Screen.height / scaleFactor) - (margin * 2);
            //width = Mathf.Clamp(width, 100, 1280);
            //height = Mathf.Clamp(height, 100, 720);

            conInput = prefabInstance.GetComponentInChildren<InputField>();
            foreach(Button btn in prefabInstance.GetComponentsInChildren<Button>())
            {
                switch(btn.name)
                {
                    case "buttonSubmit":
                        buttonSubmit = btn;
                        break;
                    case "buttonClear":
                        buttonClear = btn;
                        break;
                    default:
                        break;
                }
            }
            if(buttonSubmit != null)
            {
                buttonSubmit.onClick.AddListener(HandleInput);
            }

            foreach (UnityEngine.UI.Text txt in prefabInstance.GetComponentsInChildren<UnityEngine.UI.Text>())
            {
                switch (txt.name)
                {
                    case "conOutput":
                        conOutput = txt;
                        break;
                    default:
                        break;
                }
            }
            Content = GameObject.Find("Content");

            foreach (Toggle tgl in prefabInstance.GetComponentsInChildren<Toggle>())
            {
                switch (tgl.name)
                {
                    case "toggleError":
                        tgl.onValueChanged.AddListener(delegate {
                            logTypeFilters[LogType.Error] = tgl.isOn;
                        });
                        break;
                    case "toggleAssert":
                        tgl.onValueChanged.AddListener(delegate {
                            logTypeFilters[LogType.Assert] = tgl.isOn;
                        });
                        break;
                    case "toggleWarning":
                        tgl.onValueChanged.AddListener(delegate {
                            logTypeFilters[LogType.Warning] = tgl.isOn;
                        });
                        break;
                    case "toggleLog":
                        tgl.onValueChanged.AddListener(delegate {
                            logTypeFilters[LogType.Log] = tgl.isOn;
                        });
                        break;
                    case "toggleException":
                        tgl.onValueChanged.AddListener(delegate {
                            logTypeFilters[LogType.Exception] = tgl.isOn;
                        });
                        break;
                    default:
                        break;
                }
            }

            if (openOnStart)
            {
                isVisible = true;
                prefabInstance.SetActive(true);
                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(conInput.gameObject);
            }
            else
            {
                isVisible = false;
                prefabInstance.SetActive(false);
            }
        }

        void AddLog(string log, LogType logType)
        {
            //Utility.SkUtilities.Logz("This worked.");
            GameObject newText = new GameObject();
            UnityEngine.UI.Text text = newText.AddComponent<UnityEngine.UI.Text>();
            text.text = log;
            text.font = customFont;
            text.color = logTypeColors[logType];
            if(text.color == null)
            {
                text.color = Color.black;
            }
            var size = text.rectTransform.sizeDelta;
            size.y = logFontSize;
            text.rectTransform.sizeDelta = size;
            newText.transform.SetParent(Content.transform, false);
        }

        private void Update()
        {
            if ((!announcedCmds && SkMenuController.SkMenuControllerStatus == SkUtilities.Status.Ready) || (!announcedCmds && !Loaders.SkLoader.MenuEnabled))
            {
                Utility.SkUtilities.Logz(new string[] { "TOOLBOX", "CONSOLE", "NOTIFY" }, new string[] { SkCommandProcessor.Instance.CommandList.Count + " COMMANDS LOADED", "STATUS: READY" });
                announcedCmds = true;
            }
            if (isVisible)
            {
                UpdateQueuedLogs();
            }

            float curTime = Time.realtimeSinceStartup;


            if (Input.GetKeyDown(toggleKey))
            {
                isVisible = !isVisible;
                prefabInstance.SetActive(isVisible);
                if (!isVisible)
                {
                    conInput.text = string.Empty;
                }
                else
                {
                    conInput.text = string.Empty;
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(conInput.gameObject);
                }
            }

            if (Input.GetKeyDown(KeyCode.UpArrow))
            {
                conInput.text = consoleHistory.Fetch(conInput.text, true);
                conInput.caretPosition = conInput.text.Length;
            }

            if (Input.GetKeyDown(KeyCode.DownArrow))
            {
                conInput.text = consoleHistory.Fetch(conInput.text, false);
                conInput.caretPosition = conInput.text.Length;
            }

            if (Input.GetKeyDown(KeyCode.Return))
            {
                if (!conInput.text.Equals(string.Empty))
                {
                    HandleInput(conInput.text);
                    conInput.text = string.Empty;
                    ScrollToBottom();
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(conInput.gameObject);
                }
            }

            if (Input.GetKeyDown(KeyCode.KeypadEnter))
            {
                if (!conInput.text.Equals(string.Empty))
                {
                    HandleInput(conInput.text);
                    conInput.text = string.Empty;
                    ScrollToBottom();
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(conInput.gameObject);
                }
            }

            if (Input.GetKeyDown(KeyCode.Tab))
            {
                if (!string.IsNullOrEmpty(conInput.text))
                {
                    try
                    {
                        string[] inputSplit = conInput.text.Split(';');
                        string inputSplit2 = inputSplit[inputSplit.Length - 1].Trim().Split(' ')[0];
                        Commands.SkCommand matchCommand = SkCommandProcessor.Instance.CommandList.First(cmd =>
                                    cmd.Command.StartsWith(inputSplit2, StringComparison.InvariantCultureIgnoreCase));

                        if (!string.IsNullOrEmpty(matchCommand.Command))
                        {
                            if (inputSplit.Length > 1)
                            {
                                conInput.text = string.Empty;
                                for (int x = 0; x < inputSplit.Length - 1; x++)
                                {
                                    conInput.text += inputSplit[x].Trim() + "; ";
                                }
                                conInput.text += matchCommand.Command;
                            }
                            else
                            {
                                conInput.text = matchCommand.Command;
                            }
                            conInput.caretPosition = conInput.text.Length;
                        }
                    }
                    catch (Exception)
                    {
                        //
                    }
                }
            }

            //if (shakeToOpen &&
            //    Input.acceleration.sqrMagnitude > shakeAcceleration &&
            //    curTime - lastToggleTime >= toggleThresholdSeconds &&
            //    (!shakeRequiresTouch || Input.touchCount > 2))
            //{
            //    isVisible = !isVisible;
            //    lastToggleTime = curTime;
            //}
        }

        #endregion

        void HandleInput()
        {
            HandleInput(conInput.text);
        }

        void HandleInput(string consoleInput)
        {
            if (!string.IsNullOrEmpty(consoleInput))
            {
                if (!consoleInput.Equals("cls"))
                {
                    Utility.SkUtilities.Logz(new string[] { "IN" }, new string[] { consoleInput });
                }
                consoleHistory.Add(consoleInput);
                SkCommandProcessor.Instance.ExecuteCommand(consoleInput);

                conInput.text = string.Empty;
            }
            UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(conInput.gameObject);
        }

        private Log? GetLastLog()
        {
            if (logs.Count == 0)
            {
                return null;
            }

            return logs.Last();
        }

        private void UpdateQueuedLogs()
        {
            Log log;
            while (queuedLogs.TryDequeue(out log))
            {
                ProcessLogItem(log);
            }
        }

        private void HandleLogThreaded(string message, string stackTrace, LogType type)
        {
            Log log = new Log
            {
                count = 1,
                message = message,
                stackTrace = stackTrace,
                type = type,
            };
            if (writeToFile)
            {
                logLineNumber++;
                using (StreamWriter writer = new StreamWriter(logSavePath, true))
                {
                    //writer.WriteLine(message + "\n\t\t" + type + ": " + stackTrace.Replace("\n", "\n\t\t"));
                    writer.WriteLine(logLineNumber + "\t:\t" + message);
                }
            }

            // Queue the log into a ConcurrentQueue to be processed later in the Unity main thread,
            // so that we don't get GUI-related errors for logs coming from other threads
            queuedLogs.Enqueue(log);
        }

        private void ProcessLogItem(Log log)
        {
            Log? lastLog = GetLastLog();
            bool isDuplicateOfLastLog = lastLog.HasValue && log.Equals(lastLog.Value);

            if (isDuplicateOfLastLog)
            {
                // Replace previous log with incremented count instead of adding a new one.
                log.count = lastLog.Value.count + 1;
                logs[logs.Count - 1] = log;
            }
            else
            {
                logs.Add(log);
                AddLog(log.GetTruncatedMessage(), log.type);
                //TrimExcessLogs();
            }
        }

        private bool IsLogVisible(Log log)
        {
            return logTypeFilters[log.type];
        }

        private bool IsScrolledToBottom(Rect innerScrollRect, Rect outerScrollRect)
        {
            float innerScrollHeight = innerScrollRect.height;

            // Take into account extra padding added to the scroll container.
            float outerScrollHeight = outerScrollRect.height - GUI.skin.box.padding.vertical;

            // If contents of scroll view haven't exceeded outer container, treat it as scrolled to bottom.
            if (outerScrollHeight > innerScrollHeight)
            {
                return true;
            }

            // Scrolled to bottom (with error margin for float math)
            return Mathf.Approximately(innerScrollHeight, scrollPosition.y + outerScrollHeight);
        }

        private void ScrollToBottom()
        {
            scrollPosition = new Vector2(0, Int32.MaxValue);
        }

        private void TrimExcessLogs()
        {
            if (!restrictLogCount)
            {
                return;
            }

            int amountToRemove = logs.Count - maxLogCount;

            if (amountToRemove <= 0)
            {
                return;
            }

            logs.RemoveRange(0, amountToRemove);
        }

        public void ClearConsole()
        {
            logs.Clear();
        }

        private void unlockCursor()
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }

        private class History
        {
            public void Add(string item)
            {
                this.history.Add(item);
                this.index = 0;
            }

            public string Fetch(string current, bool next)
            {
                if (this.index == 0)
                {
                    this.current = current;
                }
                if (this.history.Count == 0)
                {
                    return current;
                }
                this.index += ((!next) ? 1 : -1);
                if (this.history.Count + this.index < 0 || this.history.Count + this.index > this.history.Count - 1)
                {
                    this.index = 0;
                    return this.current;
                }
                return this.history[this.history.Count + this.index];
            }

            public List<string> history = new List<string>();
            private int index;
            private string current;
        }
    }

    /// <summary>
    /// A basic container for log details.
    /// </summary>
    internal struct Log
    {
        public int count;
        public string message;
        public string stackTrace;
        public LogType type;

        /// <summary>
        /// The max string length supported by UnityEngine.GUILayout.Label without triggering this error:
        /// "String too long for TextMeshGenerator. Cutting off characters."
        /// </summary>
        private const int maxMessageLength = 16382;

        public bool Equals(Log log)
        {
            return message == log.message && stackTrace == log.stackTrace && type == log.type;
        }

        /// <summary>
        /// Return a truncated message if it exceeds the max message length.
        /// </summary>
        public string GetTruncatedMessage()
        {
            if (string.IsNullOrEmpty(message))
            {
                return message;
            }

            return message.Length <= maxMessageLength ? message : message.Substring(0, maxMessageLength);
        }
    }

    /// <summary>
    /// Alternative to System.Collections.Concurrent.ConcurrentQueue
    /// (It's only available in .NET 4.0 and greater)
    /// </summary>
    /// <remarks>
    /// It's a bit slow (as it uses locks), and only provides a small subset of the interface
    /// Overall, the implementation is intended to be simple & robust
    /// </remarks>
    internal class ConcurrentQueue<T>
    {
        private readonly Queue<T> queue = new Queue<T>();
        private readonly object queueLock = new object();

        public void Enqueue(T item)
        {
            lock (queueLock)
            {
                queue.Enqueue(item);
            }
        }

        public bool TryDequeue(out T result)
        {
            lock (queueLock)
            {
                if (queue.Count == 0)
                {
                    result = default(T);
                    return false;
                }

                result = queue.Dequeue();
                return true;
            }
        }
    }
}